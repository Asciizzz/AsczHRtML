<!-- Build_v0.3

All credits to Asciiz on discord
Add me on Steam: 1263698907
I am 12k elo in CS2, lvl 8 faceit

Contributions are welcome, peace!

-->

<!DOCTYPE html>
<html lang="en">
<style>
    * {
        margin: 0; padding: 0;
        box-sizing: border-box;
        font-family: monospace; user-select: none;
        transition: .3s ease color, .3s ease background, .3s ease opacity;
    }
    body {
        position: relative; background: #222;
        width: 100vw; height: 100vh;
        display: flex; overflow: hidden;
        align-items: center; justify-content: center;
    }
    #canvas { position: relative; }
    input[type="file"] { display: none; }

    .hud-cool-button {
        position: relative;
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
        width: 100%; height: 2rem;
        font-size: 1.5rem;
        overflow: hidden;
        border: 1px solid #fff;
        transition: .3s ease;
        background: none;

        padding: 0 1rem;
    }
    .hud-cool-button h1,
    .hud-cool-button h2 {
        position: relative; font-size: 1.5rem;
        transform: translateY(0.9rem);
        color: white; transition: .3s ease;
    }
    .hud-cool-button:hover { background: #fff; }
    .hud-cool-button:hover h1,
    .hud-cool-button:hover h2 {
        color: #222; transform: translateY(-0.92rem);
    }

    .hud-info > h1 {
        font-size: 2.7rem; color: #cfc;
        margin-bottom: 1rem;
    }
    .hud-info > div { margin-bottom: 1rem; }
    .hud-info > div > h2 { font-size: 2rem; }
    .hud-info > div > h3 { font-size: 1.7rem; }

    .hud-title {
        font-size: 2.5rem;
        color: #fff;
        margin-bottom: 1rem;
    }

    #hud-camera-container > h3 { color: #c33; font-size: 1.7rem; }

    .hud-light > h2 { color: #ff9; width: 100%; }
    .hud-light > h3 { color: #cc3; width: 100%; }
    .hud-light { 
        position: relative;
        padding: 2rem 1rem;
        margin: 1rem 0;
    }
    .hud-light button {
        position: absolute;
        width: 33.3%; height: 0; bottom: 0;
        transition: .3s ease;
        pointer-events: none;
        cursor: pointer; overflow: hidden;
        border: none; outline: none;
    }
    .hud-light button:nth-child(1) { left: 0; background: #9f9; }
    .hud-light button:nth-child(2) { left: 33.3%; background: #99f; }
    .hud-light button:nth-child(3) { right: 0; background: #f99; }

    .hud-light:hover button { height: 20%; pointer-events: all; }
    .hud-light:hover button:hover { height: 24%; }
    .hud-light:hover button:nth-child(1):hover { background: #5f5; }
    .hud-light:hover button:nth-child(2):hover { background: #55f; }
    .hud-light:hover button:nth-child(3):hover { background: #f55; }

    .hud-light-add {
        width: 100%;
    }

    [class^="bvh-"], [class^="bvh-"] * {
        transition: .3s ease;
    }

    .bvh-leaf, .bvh-node-title {
        display: block;
        position: relative;
        width: 100%; color: white;
        background: none; border: none;
        cursor: pointer; text-align: left;
    }
    .bvh-node-title {
        font-size: 1.5rem;
        background: rgba(85, 85, 221, 0.5);
        outline: 2px solid #55d;
    }
    .bvh-leaf {
        border-left: 8px solid #9d9;
        padding: 0.4rem 1rem;
        margin: 0.1rem 0; font-size: 1.3rem;
    }
    .bvh-node-title ~ .bvh-node {
        padding-left: 4rem;
        outline: 2px solid #55d;
    }
    .bvh-leaf:focus { outline: inherit; }
    .bvh-node-title:focus { outline: inherit; }

    .bvh-leaf:hover {  background: #7e7; color: #000; }
    .bvh-node-title:hover + .bvh-node { background: #55d; }

    #sub-hud-3 {
        padding-bottom: 1rem;
    }
    #sub-hud-3 > * {
        margin-bottom: 1rem;
    }

    #hud-menu {
        position: fixed;
        left: 0; top: 0;
        background: rgba(0, 0, 0, 0.5);
        display: flex; align-items: center;
        justify-content: center; z-index: 2;
        width: 100vw; padding: 1vh 0;

        transform: translateY(-100%);
        transition: .3s ease;
    }
    #hud-empty {
        position: fixed;
        top: 0; left: 0; z-index: 1;
        width: 100vw; height: 5vh;
    }
    #hud-empty:hover + #hud-menu,
    #hud-menu:hover {
        transform: translateY(0);
    }

    #hud-menu > label {
        cursor: pointer;
        font-size: 1.5rem;
        border: 1px solid #fff;
        color: #fff;
        
        margin: 0 2rem;
        padding: 0.2rem 1.5rem;
    }
    #hud-menu > label:hover {
        background: #fff;
        color: #000;
    }

    #hud-container {
        position: absolute;
        top: 0; left: 0; z-index: 1;
        overflow: hidden;
        pointer-events: none;

        width: 100vw; height: 100vh;
    }

    #hud-container > .sub-hud,
    #hud-container > input { display: none; }
    #hud-container > input:checked + .sub-hud {
        display: block;
    }

    .sub-hud {
        position: absolute;
        top: 0; left: 0;
        background: rgba(0, 0, 0, 0.8);
        padding: 2rem;
        pointer-events: all;

        max-width: 60vw;
        max-height: 90vh;
        overflow: auto;
    }

</style>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AsczEngineHRtML_v0.3</title>
</head>
<body>
    <canvas id="canvas"></canvas>

    <div id="hud-container">
        <!-- Camera Data -->
        <input type="checkbox" id="hud-checkbox-0">
        <div class="sub-hud" id="sub-hud-0">
            <h1 class="hud-title" style="color: #f99;">Camera</h1>
            <div id="hud-camera-container">
                <h3>| Pos: (<span id="hud-camera-pos"></span>)</h3>
                <h3>| Yaw: <span id="hud-camera-yaw"></span></h3>
                <h3>| Pit: <span id="hud-camera-pit"></span></h3>
                <h3>| Fov: <span id="hud-camera-fov"></span></h3>
                <h3>| Fw: (<span id="hud-camera-fw"></span>)</h3>
                <h3>| Rt: (<span id="hud-camera-rt"></span>)</h3>
                <h3>| Up: (<span id="hud-camera-up"></span>)</h3>
            </div>
        </div>

        <!-- Light Data -->
        <input type="checkbox" id="hud-checkbox-1">
        <div class="sub-hud" id="sub-hud-1">
            <h1 class="hud-title" style="color: #ff9;">Light Sources</h1>
            <div id="hud-light-container"></div>
        </div>

        <!-- BVH tree -->
        <input type="checkbox" id="hud-checkbox-2">
        <div class="sub-hud" id="sub-hud-2">
            <h1 class="hud-title" style="color: #55d;">BVH Tree</h1>
            <div id="hud-bvh-container"></div>
        </div>

        <!-- Settings -->
        <input type="checkbox" id="hud-checkbox-3">
        <div class="sub-hud" id="sub-hud-3">
            <input type="file" id="hud-image-loader" accept="image/*">
            <label class="hud-cool-button" id="hud-image-label" for="hud-image-loader">
                <h1>Load Texture</h1>
                <h2>Load img into Textures array</h2>
            </label>

            <button class="hud-cool-button" onclick="saveCanvasAsImage()">
                <h1>Save Image</h1>
                <h2>Download as .png</h2>
            </button>
        </div>
        
        <!-- Welcome to my world -->
        <input type="checkbox" id="hud-checkbox-4">
        <div class="sub-hud" id="sub-hud-4" style="color: #fff; max-width: 50vw;">
            <div class="hud-info">
                <h1 style="color:#99f">AsczEngineHRtML</h1>
                <hr style="margin: 1rem 0;">
                <h2>What does it do?</h2><br>
                <h3>Due to the nature of javascript and html being a single thread language, the engine is not suitable for real-time rendering. The engine is designed for educational purposes and to demonstrate the "basic" concept of ray tracing.</h3>
                <hr style="margin: 1rem 0;">
                <h2>How does it work?</h2><br>
                <h3><span style="color:#9f9">Fast Mode</span> for <span style="color:#9f9">Real-time Rendering</span> and <span style="color:#f99">Quality Mode</span> for <span style="color:#f99">High-Quality Rendering</span>.</h3><br>
                <h3><span style="color:#9f9">Fast Mode</span>: ridiculously low resolution, this helps the user navigate the scene and adjust the camera and light sources smoother since less pixels means higher frames. 
                </h3><br>
                <h3><span style="color:#f99">Quality Mode</span>: highest resolution possible (that the browser allows), and make full use of all ray tracing features. While activated, all real-time activities are halted to avoid, well, burning a hole in your house I guess.</h3>
                <hr style="margin: 1rem 0;">
                <h2>Why HTML?</h2><br>
                <h3>Cuz it's fun! And very easy to share with others. Just need to send a ~50kb file to your friends and they can run it on their browser. No need to install anything, no need to worry about compatibility, just open and run. Even your grandma PC can run this engine.</h3><br>
                <h3>Also so I can learn all ray tracing concepts before implementing them in <span style="color:#ff9">AsczEngineRT. </span>
                <hr style="margin: 1rem 0;">
                <h2>Who am I?</h2><br>
                <h3>Just someone that is really obsessed with the lowest level of programming. This ain't low level programming anymore, it's rock bottom level programming.</h3>
            </div>
        </div>
    </div>

    <div id="hud-empty"></div> <!-- To trigger hover event -->
    <div id="hud-menu">
        <label for="hud-checkbox-0">Camera</label>
        <label for="hud-checkbox-1">Light</label>
        <label for="hud-checkbox-2">BVH</label>
        <label for="hud-checkbox-3">Setting</label>
        <label for="hud-checkbox-4">Welcome</label>
    </div>
</body>
<script>
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
function resizeCanvas(width, height) {
    canvas.width = width;
    canvas.height = height;
}
resizeCanvas(window.innerWidth, window.innerHeight);

function saveCanvasAsImage() {
    const canvas = document.getElementById('canvas');
    const image = canvas.toDataURL("image/png");

    const link = document.createElement('a');
    link.href = image;
    link.download = `ascz_image_${Date.now()}.png`;
    link.click();
}

let hudSelect = -1; // Current selected window
const hudContainer = document.getElementById('hud-container');
const hudWindows = document.querySelectorAll('.sub-hud');
function selectHUDWindow(index) {
    for (let i = 0; i < hudWindows.length; i++) {
        hudWindows[i].style.opacity = i == index ? 1 : 0.3;
        hudWindows[i].style.zIndex = i == index ? 1 : 0;
    }
}
// A movable (drag) HUD window
for (let i = 0; i < hudWindows.length; i++) {
    const w = hudWindows[i];

    let preX = 0, preY = 0;
    let curX = 0, curY = 0;

    w.onmousedown = (e) => {
        let offsetX = e.clientX - w.getBoundingClientRect().left;
        let offsetY = e.clientY - w.getBoundingClientRect().top;

        document.onmousemove = (e) => {
            let winW = window.innerWidth;
            let winH = window.innerHeight;

            let x = e.clientX - offsetX;
            let y = e.clientY - offsetY;
            curX = x; curY = y;

            if (x < 0) x = 0;
            if (y < 0) y = 0;
            if (x + w.offsetWidth > winW - 1) x = winW - w.offsetWidth - 1;
            if (y + w.offsetHeight > winH - 1) y = winH - w.offsetHeight - 1;

            w.style.left = x + 'px';
            w.style.top = y + 'px';
        }

        document.onmouseup = () => {
            document.onmousemove = null;
            document.onmouseup = null;
        }
    }

    w.onclick = (e) => {
        if (curX == preX && curY == preY) selectHUDWindow(i);
        preX = curX; preY = curY;
    }
}

// Event's variables
let camSpd = 0.5;
let mSens = 0.007;
let pointerLock = false;

// Canvas pointer lock
canvas.onclick = () => canvas.requestPointerLock();
document.addEventListener('pointerlockchange', () => {
    pointerLock = document.pointerLockElement === canvas;
    selectHUDWindow(-1);
});
canvas.addEventListener('mousemove', (e) => {
    if (document.pointerLockElement !== canvas) return;

    camera.yaw += e.movementX * mSens;
    camera.pit -= e.movementY * mSens;
    camera.update();
});
document.addEventListener('wheel', (e) => {
    if (!pointerLock) return;

    camera.fov += e.deltaY > 0 ? -5 : 5;
    if (camera.fov < 10) camera.fov = 10;
    if (camera.fov > 170) camera.fov = 170;
});
// Keyboard movement event
const keys = {
    // WASD keys
    w: false, a: false, s: false, d: false,
    // Shift and control keys
    Shift: false, Control: false
}
function cameraMove() {
    if (keys.w) {
        camera.pos = Vec3f.add(camera.pos, Vec3f.mult(camera.forward, camSpd));
    } else if (keys.s) {
        camera.pos = Vec3f.sub(camera.pos, Vec3f.mult(camera.forward, camSpd));
    }

    if (keys.a) {
        camera.pos = Vec3f.sub(camera.pos, Vec3f.mult(camera.right, camSpd));
    } else if (keys.d) {
        camera.pos = Vec3f.add(camera.pos, Vec3f.mult(camera.right, camSpd));
    }
}
document.addEventListener('keydown', (e) => {
    if (e.key in keys) keys[e.key] = true;
    // Press Escape to exit pointer lock
    if (e.key == "Escape") {
        document.exitPointerLock();
    }   

    // Press Q to toggle super quality mode
    if (e.key == "q") toggleSuperQuality();

    // Press 1 -> N to toggle HUD windows
    if (e.key >= "1" && e.key <= "9") {
        let index = parseInt(e.key) - 1;
        let input = document.getElementById(`hud-checkbox-${index}`);
        if (input) input.checked = !input.checked;
    }
});
document.addEventListener('keyup', (e) => {
    if (e.key in keys) keys[e.key] = false;
});

// ============================================================ //
// ========================= Vec3f ============================ //
// ============================================================ //

class Vec3f {
    // Basic vector operations
    static mult(v, s) {
        return { x: v.x * s, y: v.y * s, z: v.z * s };
    }
    static add(v1, v2) {
        return { x: v1.x + v2.x, y: v1.y + v2.y, z: v1.z + v2.z };
    }
    static sub(v1, v2) {
        return { x: v1.x - v2.x, y: v1.y - v2.y, z: v1.z - v2.z };
    }

    static flip(v) {
        return { x: -v.x, y: -v.y, z: -v.z }
    }

    // Vector operations
    static cross(v1, v2) {
        return {
            x: v1.y * v2.z - v1.z * v2.y,
            y: v1.z * v2.x - v1.x * v2.z,
            z: v1.x * v2.y - v1.y * v2.x
        };
    }
    static dot(v1, v2) {
        return v1.x * v2.x + v1.y * v2.y + v1.z * v2.z;
    }
    static mag(v) {
        return Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);
    }
    static norm(v) {
        const mag = Vec3f.mag(v);
        return { x: v.x / mag, y: v.y / mag, z: v.z / mag };
    }

    // Other operations
    static interpolate3fx3(v1, v2, v3, u, v) {
        return {
            x: v1.x * (1 - u - v) + v2.x * u + v3.x * v,
            y: v1.y * (1 - u - v) + v2.y * u + v3.y * v,
            z: v1.z * (1 - u - v) + v2.z * u + v3.z * v
        }
    }
    static interpolate2fx3(v1, v2, v3, u, v) {
        return {
            x: v1.x * (1 - u - v) + v2.x * u + v3.x * v,
            y: v1.y * (1 - u - v) + v2.y * u + v3.y * v
        }
    }

    static lerp(v1, v2, t) {
        return Vec3f.add(Vec3f.mult(v1, 1 - t), Vec3f.mult(v2, t));
    }

    // Debug
    static toStr(v, fixed=2) {
        return `${v.x.toFixed(fixed)}, ${v.y.toFixed(fixed)}, ${v.z.toFixed(fixed)}`;
    }
}

// ============================================================ //
// ========================= BVH ============================== //
// ============================================================ //

class AABB {
    constructor(min={x:Infinity,y:Infinity,z:Infinity}, max={x:-Infinity,y:-Infinity,z:-Infinity}) {
        this.min = min;
        this.max = max;
    }

    expandMin(m) {
        this.min.x = Math.min(this.min.x, m.x);
        this.min.y = Math.min(this.min.y, m.y);         
        this.min.z = Math.min(this.min.z, m.z);
    }
    expandMax(m) {
        this.max.x = Math.max(this.max.x, m.x);
        this.max.y = Math.max(this.max.y, m.y);         
        this.max.z = Math.max(this.max.z, m.z);
    }

    expand(m) {
        this.expandMin(m);
        this.expandMax(m);
    }
}

class Node {
    constructor() {
        this.ab = new AABB();

        this.cl = -1;
        this.cr = -1;
        this.ll = -1;
        this.lr = -1;
    }

    hitDist(ray) {
        let min = this.ab.min;
        let max = this.ab.max;

        let rO = ray.origin;
        let rD = ray.direction; 

        if (rO.x >= min.x && rO.x <= max.x &&
            rO.y >= min.y && rO.y <= max.y &&
            rO.z >= min.z && rO.z <= max.z) return 0.0;

        let t1 = (min.x - rO.x) / rD.x;
        let t2 = (max.x - rO.x) / rD.x;
        let t3 = (min.y - rO.y) / rD.y;
        let t4 = (max.y - rO.y) / rD.y;
        let t5 = (min.z - rO.z) / rD.z;
        let t6 = (max.z - rO.z) / rD.z;

        let tmin = Math.max(Math.max(Math.min(t1, t2), Math.min(t3, t4)), Math.min(t5, t6));
        let tmax = Math.min(Math.min(Math.max(t1, t2), Math.max(t3, t4)), Math.max(t5, t6));

        if (tmax < tmin) return -1.0; // No intersection
        if (tmin < 0.0) return -1.0; // Behind the ray
        return tmin;
    }

    findCost() {
        let size = Vec3f.sub(this.ab.max, this.ab.min);
        let sa = size.x * size.y + size.y * size.z + size.z * size.x;

        // Cost = Surface Area * Number of primitives
        return sa * (this.lr - this.ll);
    }
}

class BVH {
    constructor() {
        this.nodes = [];

        this.geoms = [];
        this.ABs = [];

        this.gIdxs = [];

        this.root = new Node();

        this.MAX_DEPTH = 10;
        this.BIN_COUNT = 11;
        this.NODE_FACE = 2;
    }

    calcAABB() {
        for (let i = 0; i < this.geoms.length; i++) {
            let geom = this.geoms[i];
            let ab = new AABB();

            switch (geom.type) {
                case 0:
                    ab.expand(geom.v1);
                    ab.expand(geom.v2);
                    ab.expand(geom.v3);
                    break;
                case 1:
                    ab.min = Vec3f.sub(geom.pos, { x: geom.radius, y: geom.radius, z: geom.radius });
                    ab.max = Vec3f.add(geom.pos, { x: geom.radius, y: geom.radius, z: geom.radius });   
                    break;
            }

            this.ABs.push(ab);
            this.gIdxs.push(i);

            this.root.ab.expand(ab.min);
            this.root.ab.expand(ab.max);
        }

        this.root.ll = 0;
        this.root.lr = this.geoms.length;
    }

    buildBvh(node, depth=0) {
        this.nodes.push(node);

        let idx = 0;

        let nG = node.lr - node.ll;
        if (nG <= this.NODE_FACE || depth >= this.MAX_DEPTH) {
            node.cl = -1;
            node.cr = -1;
            return 1;
        }

        let nAB = node.ab;
        let nABsize = Vec3f.sub(nAB.max, nAB.min);

        let curCost = node.findCost();

        let bestAxis = -1;
        let bestSplit = -1;
        let bestCost = curCost;

        let bestLab, bestRab;

        for (let a = 0; a < 3; ++a) {
            // Sort the gIdxs by the centroid of the AABB
            
            /* Do something similar
            std::sort(allGIdxs.begin() + node.ll, allGIdxs.begin() + node.lr, [&](int i1, int i2) {
                return ABs[i1].cent()[bestAxis] < ABs[i2].cent()[bestAxis];
            });
            */

            // Splice specific range (node.ll to node.lr) and sort by centroid
            let specificGIdxs = this.gIdxs.slice(node.ll, node.lr);
            specificGIdxs.sort((i1, i2) => {
                let c1 = Vec3f.mult(Vec3f.add(this.ABs[i1].min, this.ABs[i1].max), 0.5);
                let c2 = Vec3f.mult(Vec3f.add(this.ABs[i2].min, this.ABs[i2].max), 0.5);

                return a == 0 ? c1.x - c2.x : a == 1 ? c1.y - c2.y : c1.z - c2.z;
            });
            // Combine the sorted array back to the original array
            this.gIdxs.splice(node.ll, specificGIdxs.length, ...specificGIdxs);

            for (let b = 0; b < this.BIN_COUNT; ++b) {
                let l = new Node();
                let r = new Node();

                let splitPoint = a == 0 ? nAB.min.x + nABsize.x * (b + 1) / this.BIN_COUNT :
                                 a == 1 ? nAB.min.y + nABsize.y * (b + 1) / this.BIN_COUNT :
                                          nAB.min.z + nABsize.z * (b + 1) / this.BIN_COUNT;

                let splitIdx = node.ll;

                for (let g = node.ll; g < node.lr; ++g) {
                    let i = this.gIdxs[g];

                    let cent = a == 0 ? (this.ABs[i].min.x + this.ABs[i].max.x) * 0.5 :
                               a == 1 ? (this.ABs[i].min.y + this.ABs[i].max.y) * 0.5 :
                                        (this.ABs[i].min.z + this.ABs[i].max.z) * 0.5;

                    if (cent < splitPoint) {
                        l.ab.expand(this.ABs[i].min);
                        l.ab.expand(this.ABs[i].max);
                        splitIdx++;
                    } else {
                        r.ab.expand(this.ABs[i].min);
                        r.ab.expand(this.ABs[i].max);
                    }
                }

                let cost = l.findCost() + r.findCost();
                
                if (cost < bestCost) {
                    bestCost = cost;
                    bestAxis = a;
                    bestSplit = splitIdx;
                    bestLab = l;
                    bestRab = r;
                }
            }
        }

        if (bestSplit == -1 || bestAxis == -1) {
            node.cl = -1;
            node.cr = -1;
            return 1;
        }

        // Splice (ll->lr), sort and combine
        let specificGIdxs = this.gIdxs.slice(node.ll, node.lr);
        specificGIdxs.sort((i1, i2) => {
            let c1 = Vec3f.mult(Vec3f.add(this.ABs[i1].min, this.ABs[i1].max), 0.5);
            let c2 = Vec3f.mult(Vec3f.add(this.ABs[i2].min, this.ABs[i2].max), 0.5);

            return bestAxis == 0 ? c1.x - c2.x : bestAxis == 1 ? c1.y - c2.y : c1.z - c2.z;
        }); 
        this.gIdxs.splice(node.ll, specificGIdxs.length, ...specificGIdxs);

        let l = new Node();
        l.ab = bestLab.ab;
        l.ll = node.ll; 
        l.lr = bestSplit;   

        let r = new Node(); 
        r.ab = bestRab.ab;
        r.ll = bestSplit;
        r.lr = node.lr;

        let curIdx = this.nodes.length - 1;

        this.nodes[curIdx].cl = this.nodes.length;
        idx += this.buildBvh(l, depth + 1);

        this.nodes[curIdx].cr = this.nodes.length;
        idx += this.buildBvh(r, depth + 1);

        return idx + 1;
    }

    designBvh() {
        this.calcAABB();

        this.buildBvh(this.root);

        console.log(this.nodes);
    }
}

// ============================================================ //
// ========================= Ray ============================== //
// ============================================================ //

class Ray {
    constructor(origin={x:0,y:0,z:0}, direction={x:0,y:0,z:1}, Ni=1.0, w=1.0) {
        this.origin = origin;
        this.direction = direction;
        this.Ni = Ni; // Refractive index
        this.w = w; // Weight
    }

    static rayReflect(dir, normal) {
        return Vec3f.norm(Vec3f.sub(dir, Vec3f.mult(normal, 2 * Vec3f.dot(dir, normal))));
    }

    static rayRefract(dir, normal, Ni2) {
        let Ni = 1;
        let cosI = -Vec3f.dot(dir, normal);
        if (cosI < 0) cosI = -cosI;
        else [Ni, Ni2] = [Ni2, Ni];

        let n = Ni / Ni2;
        let cosT2 = 1 - n * n * (1 - cosI * cosI);

        if (cosT2 < 0) return Ray.rayReflect(dir, normal);

        return Vec3f.norm(Vec3f.add(
            Vec3f.mult(dir, n),
            Vec3f.mult(normal, n * cosI - Math.sqrt(cosT2))
        ));
    }

    static raytrace(primray, nodes, geoms, gIdxs, lSrcs) {
        let rstack = Array(64);
        let rs_top = 0;
        rstack[rs_top++] = primray;

        let nstack = Array(64);
        let ns_top = 0;

        let resultColr = { x: 0, y: 0, z: 0 };

        while (rs_top > 0) {
            const ray = rstack[--rs_top];

            if (ray.w < 0.01) continue;

            let hit = { i: -1, t: Infinity, u: 0, v: 0 };

            ns_top = 0;
            nstack[ns_top++] = 0;

            while (ns_top > 0) {
                const nIdx = nstack[--ns_top];
                const node = nodes[nIdx];

                let hitDist = node.hitDist(ray);
                if (hitDist < 0 || hitDist > hit.t) continue;

                if (node.cl > -1) { // Node not a leaf
                    let lDist = nodes[node.cl].hitDist(ray);
                    let rDist = nodes[node.cr].hitDist(ray);     

                    if (lDist < 0 && rDist < 0) continue;
                    else if (lDist < 0) nstack[ns_top++] = node.cr;
                    else if (rDist < 0) nstack[ns_top++] = node.cl;
                    else if (lDist < rDist) {
                        nstack[ns_top++] = node.cl;
                        nstack[ns_top++] = node.cr;
                    } else {
                        nstack[ns_top++] = node.cr;
                        nstack[ns_top++] = node.cl;
                    }

                    continue;
                }

                // If node a leaf
                for (let i = node.ll; i < node.lr; ++i) {
                    const geom = geoms[gIdxs[i]];

                    const result = Geometry.intersect(ray, geom);

                    if (result.i && result.z < hit.t) {
                        hit.i = i;
                        hit.t = result.z;
                        hit.u = result.uv.u;
                        hit.v = result.uv.v;
                    }
                }
            }

            if (hit.i == -1) continue;

            const gIdx = gIdxs[hit.i];
            const gHit = geoms[gIdx];

            let interp = Geometry.interpolate(ray, gHit, hit.t, hit.u, hit.v);
            let vrtx = interp.v, nrml = interp.n, colr = interp.c;

            let NdotR = Vec3f.dot(nrml, ray.direction);
            NdotR = NdotR < 0 ? -NdotR : NdotR;

            let finalColr = {
                r: colr.r * NdotR * 0.2,
                g: colr.g * NdotR * 0.2,
                b: colr.b * NdotR * 0.2
            };

            for (let l = 0; l < lSrcs.length; ++l) {
                const lSrc = lSrcs[l];

                let lPos = lSrc.pos;
                let lDir = Vec3f.sub(vrtx, lPos);
                let lDist = Vec3f.mag(lDir);
                lDir = Vec3f.norm(lDir);

                let lRay = new Ray(lPos, lDir);

                let lI = lSrc.intensity;
                let passColr = lSrc.color;

                let shadow = false;

                ns_top = 0;
                nstack[ns_top++] = 0;

                while (ns_top > 0) {
                    const nIdx = nstack[--ns_top];
                    const node = nodes[nIdx];

                    let hitDist = node.hitDist(lRay);
                    if (hitDist < 0 || hitDist > lDist) continue;

                    if (node.cl > -1) {
                        let lDist = nodes[node.cl].hitDist(lRay);
                        let rDist = nodes[node.cr].hitDist(lRay);

                        if (lDist < 0 && rDist < 0) continue;
                        else if (lDist < 0) nstack[ns_top++] = node.cr;
                        else if (rDist < 0) nstack[ns_top++] = node.cl;
                        else if (lDist < rDist) {
                            nstack[ns_top++] = node.cl;
                            nstack[ns_top++] = node.cr;
                        } else {
                            nstack[ns_top++] = node.cr;
                            nstack[ns_top++] = node.cl;
                        }

                        continue;
                    }

                    for (let i = node.ll; i < node.lr; ++i) {
                        if (gIdxs[i] == gIdx) continue;

                        const geom = geoms[gIdxs[i]];

                        const result = Geometry.intersect(lRay, geom);

                        if (result.i && result.z < lDist) {
                            shadow = true;
                            break;
                        }
                    }
                }

                if (shadow) continue;

                let NdotL = -Vec3f.dot(nrml, lDir);

                let diff = {
                    r: colr.r * NdotL,
                    g: colr.g * NdotL,
                    b: colr.b * NdotL
                };

                let refl = Ray.rayReflect(Vec3f.flip(lDir), nrml);
                let spec = {
                    r: 0.4 * Math.pow(Vec3f.dot(refl, Vec3f.flip(ray.direction)), 32),
                    g: 0.4 * Math.pow(Vec3f.dot(refl, Vec3f.flip(ray.direction)), 32),
                    b: 0.4 * Math.pow(Vec3f.dot(refl, Vec3f.flip(ray.direction)), 32)
                }

                finalColr.r += (diff.r + spec.r) * passColr.r * lI;
                finalColr.g += (diff.g + spec.g) * passColr.g * lI;
                finalColr.b += (diff.b + spec.b) * passColr.b * lI;
            }

            if (gHit.refl > 0.0) {
                let reflD = Ray.rayReflect(ray.direction, nrml);
                let reflO = Vec3f.add(vrtx, Vec3f.mult(reflD, 0.0001)); // Slight offset
                let reflRay = new Ray(reflO, reflD, ray.Ni, ray.w * gHit.refl);

                rstack[rs_top++] = reflRay;
            }
            
            // Add result color
            resultColr.x += finalColr.r * ray.w;
            resultColr.y += finalColr.g * ray.w;
            resultColr.z += finalColr.b * ray.w;
        }


        // Clamp color
        resultColr.x = resultColr.x > 1 ? 1 : resultColr.x;
        resultColr.y = resultColr.y > 1 ? 1 : resultColr.y;
        resultColr.z = resultColr.z > 1 ? 1 : resultColr.z;

        return resultColr;
    }
}

// ============================================================ //
// ========================= Geometry ========================= //
// ============================================================ //  

class Geometry {
    static intersect(ray, geom) {
        switch (geom.type) {
            case 0: return Geometry.intersectTriangle(ray, geom);
            case 1: return Geometry.intersectSphere(ray, geom);
        }
    }

    // ========= Intersection ========= //

    static intersectTriangle(ray, geom) {
        let result = { i: false, z: 0, uv: { u: 0, v: 0 } };

        let e1 = Vec3f.sub(geom.v2, geom.v1);
        let e2 = Vec3f.sub(geom.v3, geom.v1);
        let h = Vec3f.cross(ray.direction, e2);
        let a = Vec3f.dot(e1, h);

        if (a > -0.00001 && a < 0.00001) return result;

        let f = 1 / a;
        let s = Vec3f.sub(ray.origin, geom.v1);
        let u = f * Vec3f.dot(s, h);

        if (u < 0 || u > 1) return result;

        let q = Vec3f.cross(s, e1);
        let v = f * Vec3f.dot(ray.direction, q);

        if (v < 0 || u + v > 1) return result;

        let z = f * Vec3f.dot(e2, q);

        if (z > 0.00001) {
            result.i = true;
            result.z = z;
            result.uv = { u: u, v: v };
        }

        return result;
    }

    static intersectSphere(ray, geom) {
        let result = { i: false, z: 0, uv: { u: 0, v: 0 } };

        let l = Vec3f.sub(geom.pos, ray.origin);
        let tca = Vec3f.dot(l, ray.direction);
        let d2 = Vec3f.dot(l, l) - tca * tca;

        if (d2 > geom.radius * geom.radius) return result;

        let thc = Math.sqrt(geom.radius * geom.radius - d2);
        let t0 = tca - thc;
        let t1 = tca + thc;

        if (t0 < 0) t0 = t1;

        let z = t0;

        if (z > 0.00001) {
            result.i = true;
            result.z = z;
        }

        return result;
    }
    
    // ========= Interpolation ========= //
    static interpolate(ray, geom, t, u, v) {
        switch (geom.type) {
            case 0: return Geometry.interpTriangle(ray, geom, t, u, v);
            case 1: return Geometry.interpSphere(ray, geom, t);
        }
    }

    static interpTriangle(ray, geom, t, u, v) {
        let vrtx = Vec3f.add(ray.origin, Vec3f.mult(ray.direction, t));
        let nrml = Vec3f.interpolate3fx3(geom.n1, geom.n2, geom.n3, u, v);
        nrml = Vec3f.norm(nrml);
        let colr = { r: 0, g: 0, b: 0 };

        if (geom.texture != null && textures[geom.texture]) {
            let tex = textures[geom.texture];

            let txCoord = Vec3f.interpolate2fx3(geom.t1, geom.t2, geom.t3, u, v);

            // Wrap around if texture is repeated
            if (txCoord.x < 0) txCoord.x = 1 - txCoord.x;
            if (txCoord.y < 0) txCoord.y = 1 - txCoord.y;

            txCoord.x = txCoord.x - Math.floor(txCoord.x);
            txCoord.y = txCoord.y - Math.floor(txCoord.y);

            let tx = Math.floor(txCoord.x * tex.width);
            let ty = Math.floor(txCoord.y * tex.height);
            let txColor = tex.data[tx + ty * tex.width];

            colr = { r: txColor.r, g: txColor.g, b: txColor.b }
        } else {
            // Interpolate color
            let w = 1 - u - v;
            colr = {
                r: geom.c1.r * w + geom.c2.r * u + geom.c3.r * v,
                g: geom.c1.g * w + geom.c2.g * u + geom.c3.g * v,
                b: geom.c1.b * w + geom.c2.b * u + geom.c3.b * v
            }
        }

        return { v: vrtx, n: nrml, c: colr };
    }

    static interpSphere(ray, geom, t) {
        let vrtx = Vec3f.add(ray.origin, Vec3f.mult(ray.direction, t));
        let nrml = (geom.skybox || geom.inverse) ?
            Vec3f.norm(Vec3f.sub(geom.pos, vrtx)) :
            Vec3f.norm(Vec3f.sub(vrtx, geom.pos));

        let colr = {
            r: geom.c.r,
            g: geom.c.g,
            b: geom.c.b
        }
        if (geom.texture != null && textures[geom.texture]) {
            let tex = textures[geom.texture];

            let phi = Math.acos(-normal.y);
            let theta = Math.atan2(-normal.z, -normal.x) + Math.PI;
            let u = theta / (2 * Math.PI);
            let v = phi / Math.PI;

            let tx = Math.floor(u * tex.width);
            let ty = Math.floor(v * tex.height);
            let txColor = tex.data[tx + ty * tex.width];

            colr = { r: txColor.r, g: txColor.g, b: txColor.b }
        }

        return { v: vrtx, n: nrml, c: colr };
    }
}

// ============================================================ //
// ========================= Camera =========================== //
// ============================================================ //

class Camera {
    constructor() {
        this.pos = { x: 0, y: 0, z: 0 };

        this.yaw = 0;
        this.pit = 0;

        this.fov = 90;

        this.forward = { x: 0, y: 0, z: 1 };
        this.right = { x: 1, y: 0, z: 0 };
        this.up = { x: 0, y: 1, z: 0 };
    }

    restrictRot() {
        // Restrict pit to -PI/2 to PI/2
        if (this.pit <= -Math.PI / 2) this.pit = -Math.PI / 2 + 0.001;
        else if (this.pit >= Math.PI / 2) this.pit = Math.PI / 2 - 0.001;

        // Restrict yaw to -2PI to 2PI
        if (this.yaw <= 0) this.yaw += Math.PI * 2;
        else if (this.yaw >= Math.PI * 2) this.yaw -= Math.PI * 2;
    }

    updateView() {
        this.forward = {
            x: Math.sin(this.yaw) * Math.cos(this.pit),
            y: Math.sin(this.pit),
            z: Math.cos(this.yaw) * Math.cos(this.pit)
        };
        this.forward = Vec3f.norm(this.forward);

        this.right = Vec3f.cross({ x: 0, y: 1, z: 0 }, this.forward);
        this.right = Vec3f.norm(this.right);

        this.up = Vec3f.cross(this.forward, this.right);
        this.up = Vec3f.norm(this.up);
    }

    update() {
        this.restrictRot();
        this.updateView();
    }

    getScrnNDC(x, y, w, h) {
        return {
            x: (2 * x - w) / w,
            y: (h - 2 * y) / h
        }
    }

    generateRay(x, y, w, h) {
        let ndc = this.getScrnNDC(x, y, w, h);

        let tanFov = Math.tan(this.fov * Math.PI / 360);

        let rayDir = Vec3f.add(
            this.forward,
            Vec3f.add(
                Vec3f.mult(this.right, ndc.x * tanFov * w / h),
                Vec3f.mult(this.up, ndc.y * tanFov)
            )
        );

        rayDir = Vec3f.norm(rayDir);

        return new Ray(this.pos, rayDir);
    }
}

const camera = new Camera();
camera.pos = { x: 0, y: 5, z: 0 };

// ============================================================ //
// ========================= Textures ========================= //
// ============================================================ //

// Flattened array of texture image data
let textures = [];

document.getElementById('hud-image-loader').addEventListener('change', function (e) {
    const file = e.target.files[0];
    if (!file) return;

    const imgURL = URL.createObjectURL(file);
    extractTexture(imgURL);
});

function extractTexture(src) {
    const texture = document.createElement('canvas');
    const tctx = texture.getContext('2d');
    const img = new Image();

    img.onload = function () {
        texture.width = img.width;
        texture.height = img.height;
        tctx.drawImage(img, 0, 0);

        const imgData = tctx.getImageData(0, 0, img.width, img.height).data;
        const colors = new Array(img.width * img.height);

        for (let i = 0; i < imgData.length; i += 4) {
            colors[i / 4] = {
                r: imgData[i],
                g: imgData[i + 1],
                b: imgData[i + 2]
            };
        }

        textures.push({ width: img.width, height: img.height, data: colors });
    };

    img.onerror = (err) => console.error("Failed to load image:", err);
    img.src = src;
}

// ============================================================ //
// ========================= Lights =========================== //
// ============================================================ //

// Multiple lightSrcs
let lightSrcs = [
{
    pos: { x:0, y:4, z:-10 },
    color: { r: 0.6, g: 0.6, b: 1},
    intensity: 1,

    follow: false, disabled: false
},
{
    pos: { x:0, y:4, z:10 },
    color: { r: 1, g: 0.6, b: 0.6},
    intensity: 1,

    follow: false, disabled: false
}
];
let removeLightSrc = (i) => {
    lightSrcs.splice(i, 1);
}
let toggleLightFollow = (i) => {
    lightSrcs[i].follow = !lightSrcs[i].follow;
}

// ============================================================ //
// ========================= Scene ============================ //
// ============================================================ //

// Some Geometry

let boxY = 0;
let boxWidth = 16;
let boxHeight = 5;

let boxVertices = [
    { x: -boxWidth, y: boxY, z: -boxWidth },
    { x: -boxWidth, y: boxY, z: boxWidth },
    { x: -boxWidth, y: boxY + boxHeight, z: -boxWidth },
    { x: -boxWidth, y: boxY + boxHeight, z: boxWidth },
    { x: boxWidth, y: boxY, z: -boxWidth },
    { x: boxWidth, y: boxY, z: boxWidth },
    { x: boxWidth, y: boxY + boxHeight, z: -boxWidth },
    { x: boxWidth, y: boxY + boxHeight, z: boxWidth }
]
let boxNormals = [ // Facing inwards
    { x: 1, y: 0, z: 0 },
    { x: -1, y: 0, z: 0 },
    { x: 0, y: 1, z: 0 },
    { x: 0, y: -1, z: 0 },
    { x: 0, y: 0, z: 1 },
    { x: 0, y: 0, z: -1 }
]
let box = [
    // Negative x (wall)
    { v1: boxVertices[0], v2: boxVertices[2], v3: boxVertices[3], n1: boxNormals[0], n2: boxNormals[0], n3: boxNormals[0] },
    { v1: boxVertices[0], v2: boxVertices[3], v3: boxVertices[1], n1: boxNormals[0], n2: boxNormals[0], n3: boxNormals[0] },
    // Positive x (wall)
    { v1: boxVertices[4], v2: boxVertices[7], v3: boxVertices[6], n1: boxNormals[1], n2: boxNormals[1], n3: boxNormals[1] },
    { v1: boxVertices[4], v2: boxVertices[5], v3: boxVertices[7], n1: boxNormals[1], n2: boxNormals[1], n3: boxNormals[1] },
    // Negative y (floor)
    { v1: boxVertices[0], v2: boxVertices[1], v3: boxVertices[5], n1: boxNormals[2], n2: boxNormals[2], n3: boxNormals[2] },
    { v1: boxVertices[0], v2: boxVertices[5], v3: boxVertices[4], n1: boxNormals[2], n2: boxNormals[2], n3: boxNormals[2] },
    // Positive y (ceiling)
    { v1: boxVertices[2], v2: boxVertices[6], v3: boxVertices[7], n1: boxNormals[3], n2: boxNormals[3], n3: boxNormals[3] },
    { v1: boxVertices[2], v2: boxVertices[7], v3: boxVertices[3], n1: boxNormals[3], n2: boxNormals[3], n3: boxNormals[3] },
    // Negative z (wall)
    { v1: boxVertices[0], v2: boxVertices[4], v3: boxVertices[6], n1: boxNormals[4], n2: boxNormals[4], n3: boxNormals[4] },
    { v1: boxVertices[0], v2: boxVertices[6], v3: boxVertices[2], n1: boxNormals[4], n2: boxNormals[4], n3: boxNormals[4] },
    // Positive z (wall)
    { v1: boxVertices[1], v2: boxVertices[3], v3: boxVertices[7], n1: boxNormals[5], n2: boxNormals[5], n3: boxNormals[5] },
    { v1: boxVertices[1], v2: boxVertices[7], v3: boxVertices[5], n1: boxNormals[5], n2: boxNormals[5], n3: boxNormals[5] }
];
let boxColor = { r: 0.5, g: 0.5, b: 1 };
boxColor = { r: 1, g: 1, b: 1 };
for (let i = 0; i < box.length; i++) {
    box[i].type = 0;
    box[i].c1 = boxColor;
    box[i].c2 = boxColor;
    box[i].c3 = boxColor;
    // Additional attributes if needed
}

// Create a wall in the middle of the box to separate the box
let wallN1 = { x: 0, y: 0, z: -1 };
let wallN2 = { x: 0, y: 0, z: 1 };
let wallC = { r: 0, g: 1, b: 0 };

let wall1a = {
    type: 0,
    v1: { x: -boxWidth, y: boxY, z: -0.01 },
    v2: { x: -boxWidth, y: boxY + boxHeight, z: -0.01 },
    v3: { x: boxWidth, y: boxY + boxHeight, z: -0.01 },
    n1: wallN1, n2: wallN1, n3: wallN1,
    c1: wallC, c2: wallC, c3: wallC
};
let wall1b = {
    type: 0,
    v1: { x: boxWidth, y: boxY, z: -0.01 },
    v2: { x: boxWidth, y: boxY + boxHeight, z: -0.01 },
    v3: { x: -boxWidth, y: boxY, z: -0.01 },
    n1: wallN1, n2: wallN1, n3: wallN1,
    c1: wallC, c2: wallC, c3: wallC
};
let wall2a = {
    type: 0,
    v1: { x: -boxWidth, y: boxY, z: 0.01 },
    v2: { x: -boxWidth, y: boxY + boxHeight, z: 0.01 },
    v3: { x: boxWidth, y: boxY + boxHeight, z: 0.01 },
    n1: wallN2, n2: wallN2, n3: wallN2,
    c1: wallC, c2: wallC, c3: wallC
};
let wall2b = {
    type: 0,
    v1: { x: boxWidth, y: boxY, z: 0.01 },
    v2: { x: boxWidth, y: boxY + boxHeight, z: 0.01 },
    v3: { x: -boxWidth, y: boxY, z: 0.01 },
    n1: wallN2, n2: wallN2, n3: wallN2,
    c1: wallC, c2: wallC, c3: wallC
};

box[4].debug1 = 1;
box[5].debug1 = 1;
box[4].texture = 1;
box[5].texture = 1;
box[4].t1 = { x: 0, y: 1 };
box[4].t2 = { x: 0, y: 0 };
box[4].t3 = { x: 1, y: 0 };
box[5].t1 = { x: 0, y: 1 };
box[5].t2 = { x: 1, y: 0 };
box[5].t3 = { x: 1, y: 1 };

box[4].refl = 0.5;
box[5].refl = 0.5;

// Remove the ceiling
box.splice(6, 2);

// Create a bunch of spheres
let sphX = 7;
let sphZ = 7;
let sphR = 1;
let sphU = 2;

let spheres = [];
for (let x = -sphX; x <= sphX; x += sphU) {
    for (let z = -sphZ; z <= sphZ; z += sphU) {
        spheres.push({
            type: 1,
            pos: { x: x * sphU, y: sphR, z: z * sphU },
            radius: sphR,
            c: { r: Math.random(), g: Math.random(), b: Math.random() },
            // refl: 0.5
        });
    }
}

// Initialize BVH
const bvh = new BVH();
bvh.geoms.push(...box, wall1a, wall1b, wall2a, wall2b, ...spheres);
bvh.designBvh();


// Some settings
let scale = 11;
let width = Math.floor(window.innerWidth / scale);
let height = Math.floor(window.innerHeight / scale);

let superQuality = false;

function toggleSuperQuality() {
    superQuality = !superQuality;
    if (superQuality) {
        scale = 1;
        width = window.innerWidth;
        height = window.innerHeight;
    } else {
        scale = 10;
        width = Math.floor(window.innerWidth / scale);
        height = Math.floor(window.innerHeight / scale);
    }

    // In super quality mode, turn off the interval
    if (superQuality) {
        clearInterval(interval);
        document.exitPointerLock();
        renderQuality();

        staticUpdateHud();
        runtimeUpdateHud();
    } else {
        interval = setInterval(renderFast, 1000 / 60);
    }
}
window.onresize = () => {
    // Ignore resizing in super quality mode
    if (superQuality) return;

    resizeCanvas(window.innerWidth, window.innerHeight);
    width = Math.floor(window.innerWidth / scale);
    height = Math.floor(window.innerHeight / scale);
}

function aliasUpdate(id, value) {
    document.getElementById(id).innerHTML = value;
}

function runtimeUpdateHud() {
    aliasUpdate("hud-camera-pos", Vec3f.toStr(camera.pos));
    aliasUpdate("hud-camera-yaw", `${camera.yaw.toFixed(2)}rad | ${(camera.yaw * 180 / Math.PI).toFixed(2)}°`);
    aliasUpdate("hud-camera-pit", `${camera.pit.toFixed(2)}rad | ${(camera.pit * 180 / Math.PI).toFixed(2)}°`);
    aliasUpdate("hud-camera-fov", `${camera.fov}°`);
    aliasUpdate("hud-camera-fw", Vec3f.toStr(camera.forward));
    aliasUpdate("hud-camera-rt", Vec3f.toStr(camera.right));
    aliasUpdate("hud-camera-up", Vec3f.toStr(camera.up));

    const hudLight = document.getElementsByClassName("hud-light");
    const hudLightPos = document.getElementsByClassName("hud-light-pos");
    const hudLightFollow = document.getElementsByClassName("hud-light-follow");
    const hudLightColor = document.getElementsByClassName("hud-light-color");

    for (let i = 0; i < lightSrcs.length; i++) {
        if (!hudLight[i]) continue;

        hudLight[i].style.border = `1px solid ${lightSrcs[i].disabled?'#f99':'#9f9'}`;

        hudLightPos[i].innerHTML = `| Position: (${Vec3f.toStr(lightSrcs[i].pos)})`;
        hudLightFollow[i].innerHTML = `| Follow: ${lightSrcs[i].follow?
            "<span style='color:#9f9'>[ON]</span>":
            "<span style='color:#f99'>[OFF]</span>"
        }`;

        hudLightColor[i].innerHTML = `| Color: (${lightSrcs[i].color.r}, ${lightSrcs[i].color.g}, ${lightSrcs[i].color.b})`;
        hudLightColor[i].style.color = `rgb(${lightSrcs[i].color.r*255}, ${lightSrcs[i].color.g*255}, ${lightSrcs[i].color.b*255})`;
    }
}
function staticUpdateHud() {
    // Update Light Sources Container
    const hudLightContainer = document.getElementById("hud-light-container");
    hudLightContainer.innerHTML = "";
    for (let i = 0; i < lightSrcs.length; i++) {
        hudLightContainer.innerHTML += (`
        <div class="hud-light" style="color:#fff;">
            <h2>Light ${i + 1}</h2>
            <h3 class="hud-light-pos"></h3>
            <h3 class="hud-light-follow"></h3>
            <h3 class="hud-light-color"></h3>
            <div>
                <button onclick="toggleLightFollow(${i})">Follow</button>
                <button onclick="lightSrcs[${i}].disabled=!lightSrcs[${i}].disabled">Toggle</button>
                <button onclick="removeLightSrc(${i});staticUpdateHud()">Remove</button>
            </div>
        </div>
        `);
    }
    hudLightContainer.innerHTML += (`
    <button class="hud-cool-button" onclick="
        lightSrcs.push({pos:{x:0,y:0,z:0},follow:true,color:{r:1,g:1,b:1}});
        staticUpdateHud()
    ">
        <h1>Add Light</h1>
        <h2>+1</h2>
    </button>
    `);
};
staticUpdateHud();

let fps = 0;
let frameCount = 0;
let lastTime = Date.now();

// Fast render (low quality)
function renderFast() {
    for (light of lightSrcs) {
        if (light.follow) {
            light.pos = camera.pos;
        }
    }

    frameCount++;
    let currentTime = Date.now();
    if (currentTime - lastTime >= 1000) {
        fps = frameCount;
        frameCount = 0;
        lastTime = currentTime;
    }

    // Paint everything black
    ctx.clearRect(0, 0, width * scale, height * scale);
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, width * scale, height * scale);

    for (let x = 0; x < width; x++) {
        for (let y = 0; y < height; y++) {
            let ray = camera.generateRay(x, y, width, height);
            let result = Ray.raytrace(
                ray, bvh.nodes, bvh.geoms, bvh.gIdxs, lightSrcs
            );
            result.x *= 255; result.y *= 255; result.z *= 255;

            ctx.fillStyle = `rgb(${result.x}, ${result.y}, ${result.z})`;
            ctx.fillRect(x * scale, y * scale, scale, scale);
        }
    }


    // ====================================================== //
    // Processes that mostly don't contribute to the pipeline //
    // ====================================================== //
    cameraMove();

    // Draw a crosshair
    ctx.strokeStyle = 'white';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(width / 2 * scale, height / 2 * scale - 4);
    ctx.lineTo(width / 2 * scale, height / 2 * scale + 4);
    ctx.moveTo(width / 2 * scale - 4, height / 2 * scale);
    ctx.lineTo(width / 2 * scale + 4, height / 2 * scale);
    ctx.stroke();

    // Update the HUD
    runtimeUpdateHud();
}

// Super Quality render (high quality) (not clickbait) (cop's called) (gone wrong)
function renderQuality() {
    // Paint everything black
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, width * scale, height * scale);

    for (let x = 0; x < width; x++) {
        for (let y = 0; y < height; y++) {
            let ray = camera.generateRay(x, y, width, height);
            let result = Ray.raytrace(
                ray, bvh.nodes, bvh.geoms, bvh.gIdxs, lightSrcs
            );
            result.x *= 255; result.y *= 255; result.z *= 255;

            ctx.fillStyle = `rgb(${result.x}, ${result.y}, ${result.z})`;
            ctx.fillRect(x * scale, y * scale, scale, scale);
        }
    }
}

let interval = setInterval(renderFast, 1000 / 60);

</script>
</html>